<?php

namespace AppBundle\Repository;

use AppBundle\Entity\Competitor;
use AppBundle\Entity\Event;
use AppBundle\Entity\Race;
use AppBundle\Entity\RaceSection;
use AppBundle\Entity\RaceSectionStatus;
use AppBundle\Entity\Registration;
use AppBundle\Entity\TeamPosition;
use Doctrine\Common\Collections\ArrayCollection;
use Doctrine\ORM\NoResultException;
use Psr\Log\LoggerInterface;

/**
 * RaceRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class RaceRepository extends \Doctrine\ORM\EntityRepository
{
    public function findAllForEvent($id) {
        return $this->findBy(array('event' => $id), array('numberInEvent' => 'ASC'));
    }

    public function findAllByEventForChanges(Race $race)
    {
        $all = $this->findAllForEvent($race->getEvent()->getId());

        $checkGender = !$this->isMixedGender($race);

        foreach(array_keys($all) as $key) {
            if ($all[$key]->getId() == $race->getId()) {
                // remove the given race from result set
                unset($all[$key]);
            } elseif ($race->getTeamsize() < $all[$key]->getTeamsize()) {
                // number of max starters per team has to be same or
                // greater so that the moved one fits into
                unset($all[$key]);
            } elseif ($race->getAgeMin() > $all[$key]->getAgeMax()) {
                // competitors allowed to start against older teams but not against younger ones
                unset($all[$key]);
            } elseif (($race->getAgeMax() * 1.3) < $all[$key]->getAgeMin()) {
                // it does not make sence to let people start in classes with much older ones
                unset($all[$key]);
            } elseif ($checkGender && !$this->isMixedGender($all[$key])) {
                // gender has to match
                if ($race->getGender() != $all[$key]->getGender()) {
                    unset($all[$key]);
                }
            }
        }

        // convert change array key values so that they match the ID in the database
        $result = array();
        /** @var Race $r */
        foreach($all as $r) {
            $result[$r->getId()] = $r;
        }

        return $result;
    }

    /**
     * @param Race $race
     * @return bool <tt>TRUE</tt> if any corresponding section has started but is not yet finished.
     */
    public function isStarted(Race $race)
    {
        return (0 < $this->hasAnySectionWithStatus($race, RaceSectionStatus::STARTED));
    }

    public function isFinished(Race $race)
    {
        $total = $race->getSections()->count();
        if (0 == $total) {
            return false;
        }
        $finished = $this->hasAnySectionWithStatus($race, RaceSectionStatus::FINISHED);
        return ($total == $finished);
    }

    private function hasAnySectionWithStatus(Race $race, $status)
    {
        $em = $this->getEntityManager();
        $qb = $em->createQueryBuilder();
        // Ask if number of sections associated with race in status "running" is greater then 0"
        $qb->select('COUNT(r) amount')
            ->from('AppBundle:RaceSection', 'r')
            ->where($qb->expr()->eq('r.race', '?1'))
            ->andWhere($qb->expr()->eq('r.status', '?2'))
            ->setParameter(1, $race->getId())
            ->setParameter(2, $status);
        return  (int) $qb->getQuery()->getSingleScalarResult();
    }

    private function isMixedGender(Race $race)
    {
        return ('a' == $race->getGender());
    }

    public static function getOfficialName(Race $race) {
        $name = '';

        switch($race->getAgeClass()) {
            case 'Kind':
                if ($race->getGender() == Competitor::GENDER_FEMALE) {
                    $name = 'M채dchen';
                } elseif($race->getGender() == Competitor::GENDER_MALE) {
                    $name = 'Jungen';
                } else {
                    $name = 'JuM';
                }
                $name .= self::getAgeClassSuffix($race->getAgeMin(), $race->getAgeMax());
                break;
            case 'Junior':
                if ($race->getGender() == Competitor::GENDER_FEMALE) {
                    $name = 'Juniorinnen';
                } else {
                    $name = 'Junioren';
                }

                if ($race->getAgeMin() == 15 && ($race->getAgeMax() == 16 || $race->getAgeMax() == $race->getAgeMin())) {
                    $name .= ' B';
                } elseif ($race->getAgeMin() == 17 && ($race->getAgeMax() == 18 || $race->getAgeMax() == $race->getAgeMin())) {
                    $name .= ' A';
                }
            break;
            case 'Senior':
                if ($race->getGender() == Competitor::GENDER_FEMALE) {
                    $name = 'Frauen';
                } elseif($race->getGender() == Competitor::GENDER_MALE) {
                    $name = 'M채nner';
                } else {
                    $name = 'Senioren';
                }

                if ($race->getAgeMax() < 23) {
                    $name .= ' B';
                } elseif ($race->getAgeMin() > 22 && $race->getAgeMax() < 27) {
                    $name .= ' A';
                } else {
                    $name .= self::getAgeClassSuffix($race->getAgeMin(), $race->getAgeMax());
                }
            break;
            case 'Master':
                if ($race->getGender() == Competitor::GENDER_FEMALE) {
                    $name = 'Frauen (Masters)';
                } elseif($race->getGender() == Competitor::GENDER_MALE) {
                    $name = 'M채nner (Masters)';
                } else {
                    $name = 'Masters';
                }
                $name .= self::getAgeClassSuffix($race->getAgeMin(), $race->getAgeMax());
            break;
            case 'Offen':
                $name = 'Offen';
                $name .= self::getAgeClassSuffix($race->getAgeMin(), $race->getAgeMax());
            break;
        }

        if ($race->hasWeightLimit()) {
            $name .= " Lgw.";
        }

        if ($race->getTeamsize() > 1) {
            $name .= ' ['.$race->getTeamsize().' Pers.]';
        }

        return $name;
    }

    /**
     * Get all races that have at least one registered starter and ignore all those without.
     *
     * @param int $eventId The ID of the event.
     * @return array The races with registrations.
     */
    public function getAllRacesThatHaveRegistrations($eventId)
    {
        $races = array();
        foreach($this->findAllForEvent($eventId) as $r) {
            if (0 < $this->getNumberOfRegistrations($r)) {
                $races[] = $r;
            }
        }
        return $races;
    }

    /**
     * Get all competitors that start in the given race.
     *
     * @param Race $race The race to inspect.
     * @return ArrayCollection[Membership] All competitors.
     */
    public function findAllCompetitors(Race $race)
    {
        $result = new ArrayCollection();
        /** @var RaceSection $section */
        foreach($race->getSections() as $section) {
            /** @var Registration $registration */
            foreach($section->getRegistrations() as $registration) {
                /** @var TeamPosition $member */
                foreach($registration->getTeam()->getMembers() as $member) {
                    $result->add($member->getMembership());
                }
            }
        }
        return $result;
    }

    /**
     * Create a suffix for an age interval (x to y years)
     *
     * @param $min int minimal age
     * @param $max int maximal age
     * @return string best matching age interval string
     */
    private function getAgeClassSuffix($min, $max) {
        if ($min > 1) {
            $suff = 'e';
        } else {
            $suff = '';
        }
        if ($min == $max) {
            $result = " ({$min} Jahr{$suff})";
        } else if (99 == $max) {
            $result = " ({$min} Jahr{$suff} u.채.)";
        } else {
            if ($max > 1) {
                $suff = 'e';
            } else {
                $suff = '';
            }
            $result = " ({$min} bis {$max} Jahr{$suff})";
        }
        return $result;
    }

    public function getNumberOfRegistrations(Race $race) {
        $result = 0;
        /** @var RaceSection $section */
        foreach($race->getSections() as $section) {
            $result += $section->getValidRegistrations()->count();
        }
        return $result;
    }

    public function getLastNumberForEvent(Event $event) {
        $em = $this->getEntityManager();
        $qb = $em->createQueryBuilder();
        $qb->select('MAX(r.numberInEvent) maxNum')
            ->from('AppBundle:Race', 'r')
            ->orderBy('r.numberInEvent', 'DESC')
            ->where($qb->expr()->eq('r.event', '?1'))
            ->setParameter(1, $event->getId());
        return (int) $qb->getQuery()->getSingleScalarResult();
    }

    public function createNewSection(Race $race, LoggerInterface $logger = null)
    {
        $max = 0;
        $query = $this->createQueryBuilder('r')
            ->select('MAX(section.number) AS m')
            ->innerJoin('r.sections', 'section')
            ->where('r.id = :rId')
            ->setParameter('rId', $race->getId())
            ->getQuery();
        try {
            $max = $query->getSingleScalarResult();
        } catch (NoResultException $e) {
            if (!is_null($logger)) {
                $logger->warning("Could not query max section number for race {$race->getId()}");
            }
        }
        $number = $max + 1;

        $em = $this->getEntityManager();

        $section = new RaceSection();
        $section->setRace($race)
            ->setNumber($number);
        $em->persist($section);
        if (!is_null($logger)) {
            $logger->info("Create section #{$number} for race {$race->getId()}");
        }
        $em->flush();
        $em->refresh($race);
        $em->refresh($section);

        return $section;
    }

    public function createOrUpdate(\AppBundle\DRV_Import\Race $race, Event $event, LoggerInterface $logger)
    {
        /** @var Race $dbItem */
        $dbItem = null;
        $em = $this->getEntityManager();

        $dbItem = $this->findOneBy(array('event' => $event, 'numberInEvent' => $race->number));
        if (null != $dbItem) {
            // TODO update
            // $extraText
            $logger->warning("Implementation missing for updating of races in RaceRepository::createOrUpdate");
        } else {
            // TODO create
            $logger->warning("Implementation missing for creation of new races in RaceRepository::createOrUpdate");
        }

        return $dbItem;
    }
}
